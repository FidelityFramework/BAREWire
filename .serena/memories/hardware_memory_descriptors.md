# BAREWire Hardware Memory Descriptor System

## The "Fidelity" Principle

> **The entire point of Fidelity is that the F# compiler controls memory layout - not MLIR, not LLVM.**

Types (including memory region types, access kinds, and peripheral descriptors) carry semantic meaning through the entire compilation pipeline. They ARE erased - but at the **last possible lowering stage**, after Fidelity has made all memory layout decisions. **Fidelity dictates; LLVM implements.**

## Status: NOT YET IMPLEMENTED

The types and concepts described below are the **design specification** for what BAREWire needs
to provide as Farscape's foundation. As of this assessment, these types DO NOT EXIST in BAREWire.

### Current BAREWire State
- Has: BARE type system, Memory/Region/View abstractions, Schema system, UoM
- Missing: Hardware-specific descriptors, fixed-address semantics, volatile access primitives
- Gap: Memory model is dynamic (byte[]), not fixed-address hardware registers

### Implementation Status (December 2025)

Platform cruft has been removed from BAREWire. The remaining structure is:
- Core types (BARE type system, error handling)
- Memory abstractions (Region, View, Mapping types)
- Schema system (DSL, validation, analysis)
- Encoding/Decoding (BARE wire format)

## Future: BAREWire.[DeviceClass] Pattern

Hardware memory descriptors will be implemented as separate modules, e.g.:
- `BAREWire.STM32L5` - generated by Farscape from CMSIS headers
- `BAREWire.NRF52` - generated for Nordic chips
- `BAREWire.RP2040` - generated for Raspberry Pi Pico

Each device class module:
1. References BAREWire.Core for abstract types
2. Contains generated peripheral descriptors (addresses, registers, bit fields)
3. Gets compiled by Firefly with Alex providing platform bindings

## Farscape Dependency Relationship

BAREWire serves as a foundational dependency for Farscape. When Farscape parses C/C++ headers for hardware targets (CMSIS, HAL libraries), it needs BAREWire types to express the hardware memory catalog.

**BAREWire development should advance in parallel with Farscape** to provide the memory descriptor infrastructure.

## Core Design: Invisible Memory Management

From "Memory Management By Choice":
> "In the mature phase, developers write idiomatic F# without memory annotations... The compiler identifies patterns and employs region-based memory management, eliminating individual allocations and providing deterministic cleanup without explicit developer intervention."

For hardware targets, this means:
- Developer writes clean F# peripheral access code
- Compiler uses memory descriptors to generate correct hardware access
- Tree-shaking keeps only used peripherals
- No manual memory/layout management required

## Hardware Memory Descriptor Types (Needed by Farscape)

BAREWire should provide these types for hardware memory description:

```fsharp
/// Describes a memory-mapped peripheral
type PeripheralDescriptor = {
    Name: string                          // "GPIO", "USART", etc.
    Instances: Map<string, unativeint>    // GPIOA → 0x48000000
    Layout: PeripheralLayout
    MemoryRegion: MemoryRegionKind
}

/// Layout of a peripheral's register set
and PeripheralLayout = {
    Size: int                             // Total size in bytes
    Alignment: int                        // Required alignment
    Fields: FieldDescriptor list          // Individual registers
}

/// Single register within a peripheral
and FieldDescriptor = {
    Name: string                          // "ODR", "BSRR", etc.
    Offset: int                           // Byte offset from base
    Type: RegisterType                    // u32, u16, u8
    Access: AccessKind                    // RO, WO, RW
    BitFields: BitFieldDescriptor list option  // Sub-register fields
    Documentation: string option
}

/// Hardware-enforced access constraints
and AccessKind = 
    | ReadOnly   // __I in CMSIS - reads hardware state, writes are UB
    | WriteOnly  // __O in CMSIS - writes trigger action, reads undefined
    | ReadWrite  // __IO in CMSIS - normal volatile access

/// Memory region classification
and MemoryRegionKind =
    | Flash           // Code/constants, read-only at runtime
    | SRAM            // Normal RAM (stack, heap, globals)
    | Peripheral      // Memory-mapped I/O, volatile, uncacheable
    | SystemControl   // ARM system peripherals (NVIC, SysTick)
    | DMA             // DMA-accessible regions
    | CCM             // Core-coupled memory (if present)

/// Bit field within a register (from _Pos/_Msk macros)
and BitFieldDescriptor = {
    Name: string      // "UE" in USART_CR1_UE
    Position: int     // Bit position (from _Pos macro)
    Width: int        // Number of bits
    Access: AccessKind
}
```

## Microcontroller Memory Map Model

Different memory regions have different characteristics:

| Region | Typical Address | Characteristics |
|--------|-----------------|-----------------|
| Flash | `0x0800_0000` | Execute-in-place, read-only at runtime |
| SRAM | `0x2000_0000` | Stack, heap, .bss, .data |
| Peripherals | `0x4000_0000+` | Volatile, specific access widths |
| System | `0xE000_0000` | ARM core peripherals |

Alex (in Firefly) uses `MemoryRegionKind` to determine:
- Whether to emit volatile access
- Cache behavior hints
- Valid access widths

## Access Kind Semantics

CMSIS uses `__I`, `__O`, `__IO` qualifiers that encode hardware constraints:

- **ReadOnly (`__I`)**: Hardware state register. Writing is undefined behavior.
  - Example: `GPIO->IDR` (input data register)
  
- **WriteOnly (`__O`)**: Trigger register. Reading returns undefined.
  - Example: `GPIO->BSRR` (bit set/reset register)
  
- **ReadWrite (`__IO`)**: Normal register with defined read/write behavior.
  - Example: `GPIO->ODR` (output data register)

Code generation MUST respect these constraints for correct hardware operation.

## Integration with Existing BAREWire

The hardware descriptor system extends BAREWire's existing concepts:

- `Region<'T, 'region>` → Hardware region at fixed address
- `View<'T, 'region>` → Type-safe register access via descriptors
- `BARELayout<'T>` → Generalized to `PeripheralLayout`

Key difference: hardware regions have **fixed addresses** known at compile time, not dynamically allocated.

## Compilation Pipeline Role

```
Farscape parses CMSIS headers
    ↓
Populates BAREWire PeripheralDescriptors
    ↓
Stored in generated F# module
    ↓
Firefly PSG captures descriptors
    ↓
Alex uses descriptors for MLIR generation:
    - Peripheral access → volatile load/store at correct offset
    - Access kind → read-only/write-only enforcement
    - Memory region → cache/barrier hints
```

## Future: Unified Memory Description

The hardware descriptor system should eventually unify with BAREWire's IPC/serialization memory descriptions:

- **Hardware peripherals**: Fixed addresses, volatile, hardware-constrained access
- **Shared memory IPC**: Dynamic addresses, potentially volatile, software-defined layout
- **Network buffers**: Dynamic, schema-driven, serialization-aware

All use the same underlying memory layout primitives, with different allocation and access semantics.
