# BAREWire's Role in Native Library Binding

## The "Fidelity" Principle

> **The entire point of Fidelity is that the F# compiler controls memory layout - not MLIR, not LLVM.**

BAREWire's memory descriptors carry semantic meaning through the compilation pipeline. They guide every memory layout decision Fidelity makes, and are erased only at the last possible lowering stage. **Fidelity dictates; LLVM implements.**

## Position in the Three-Layer Architecture

BAREWire is **Layer 2** in the Fidelity binding architecture - it provides memory description vocabulary via quotation semantic carriers:

| Layer | What | Examples |
|-------|------|----------|
| Layer 1 | FNCS Intrinsics | `Sys.write`, `NativePtr.*` |
| **Layer 2** | **Binding Libraries (including BAREWire)** | Memory layouts, peripheral descriptors |
| Layer 3 | User Code | Fidelity.Platform, applications |

```
Farscape (parses C headers) → BAREWire.[Target] (quotation descriptors) → FNCS (inspects at compile time) → Alex (generates MLIR)
```

BAREWire.Core provides abstract types. BAREWire.[Target] modules (generated by Farscape) contain concrete hardware descriptions as quotation semantic carriers.

## What BAREWire Provides

### Core Abstractions (BAREWire.Core)
- `MemoryRegionKind`: Flash, SRAM, Peripheral, SystemControl, DMA
- `AccessKind`: ReadOnly, WriteOnly, ReadWrite
- Schema types for binary layouts
- Memory/Region/View abstractions

### Target-Specific Descriptors (BAREWire.[Target])
Generated by Farscape, e.g., `BAREWire.STM32L5`:

```fsharp
type PeripheralDescriptor = {
    Name: string
    Region: MemoryRegionKind
    Instances: Map<string, unativeint>  // GPIOA → 0x48000000
    Registers: RegisterDescriptor list
}

type RegisterDescriptor = {
    Name: string
    Offset: int
    Width: int           // 8, 16, 32
    Access: AccessKind   // from CMSIS __I/__O/__IO
    BitFields: BitFieldDescriptor list
}
```

## How Alex Uses BAREWire Descriptors

Alex doesn't import BAREWire directly. The descriptors flow through the PSG as:
- Constant addresses (unativeint literals)
- Memory region markers (attached to nodes)
- Access constraints (for validation)

Alex responds to these patterns:
- `MemoryRegionKind.Peripheral` → volatile load/store
- `AccessKind.WriteOnly` → error on read attempt
- `AccessKind.ReadOnly` → error on write attempt

## What BAREWire Does NOT Do

- Implement platform-specific operations (that's Alex's job)
- Contain syscall bindings (that's Fidelity.Platform/Alex)
- Parse C headers (that's Farscape)
- Generate MLIR/LLVM (that's Alex)

## Relationship to Other Projects

| Project | Relationship |
|---------|--------------|
| **Fidelity.Platform** | BAREWire depends on Fidelity.Platform for primitive operations |
| **Farscape** | Farscape generates BAREWire.[Target] modules |
| **Firefly** | Firefly compiles code using BAREWire types; Alex interprets markers |

## Canonical Document

See Farscape `/docs/01_Architecture_Overview.md` and Firefly `/docs/Quotation_Based_Memory_Architecture.md` for the binding architecture.
